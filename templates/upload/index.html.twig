{% extends 'base.html.twig' %}

{% block title %}Upload - FastDrop{% endblock %}

{% block body %}
<div class="d-flex justify-content-between align-items-center mb-4">
    <h1><i class="bi bi-upload"></i> Upload de fichier</h1>
    <a href="{{ path('dashboard') }}" class="btn btn-outline-secondary">
        <i class="bi bi-arrow-left"></i> Retour au dashboard
    </a>
</div>

<div class="row">
    <div class="col-md-8">
        <!-- Upload par glisser-déposer uniquement -->
        <div class="card mb-4">
            <div class="card-header">
                <h5><i class="bi bi-cloud-upload"></i> Upload par glisser‑déposer</h5>
            </div>
            <div class="card-body">
                <div>
                    <h6><i class="bi bi-cloud-upload"></i> Upload par chunks (recommandé pour fichiers > 100MB)</h6>
                    <p class="text-muted">Cette méthode permet d'uploader des fichiers très volumineux de manière fiable.</p>
                    
                    <div id="chunkedUploadArea">
                        <div class="upload-dropzone" id="dropzone">
                            <div class="dropzone-content">
                                <i class="bi bi-cloud-upload dropzone-icon" style="font-size: 3rem; color: #6c757d;"></i>
                                <h5 class="mt-3 dropzone-title">Glissez-déposez vos fichiers ici</h5>
                                <p class="text-muted dropzone-subtitle">ou cliquez pour sélectionner des fichiers</p>
                                <div class="dropzone-info mt-3">
                                    <small class="text-muted">
                                        <i class="bi bi-info-circle"></i>
                                        Support multi-fichiers • Max 10GB par fichier
                                    </small>
                                </div>
                            </div>
                            <div class="dropzone-overlay" style="display: none;">
                                <div class="dropzone-overlay-content">
                                    <i class="bi bi-cloud-upload" style="font-size: 4rem; color: #007bff;"></i>
                                    <h4 class="mt-3">Relâchez pour uploader</h4>
                                    <p class="text-muted">Fichiers détectés: <span id="fileCount">0</span></p>
                                </div>
                            </div>
                            <input type="file" id="chunkedFileInput" style="display: none;" multiple>
                        </div>

                        <!-- Preview des fichiers -->
                        <div id="filePreview" style="display: none;" class="mt-4">
                            <div class="card">
                                <div class="card-header d-flex justify-content-between align-items-center">
                                    <h6><i class="bi bi-files"></i> Fichiers sélectionnés</h6>
                                    <button type="button" class="btn btn-sm btn-outline-secondary" id="clearFiles">
                                        <i class="bi bi-x"></i> Tout effacer
                                    </button>
                                </div>
                                <div class="card-body">
                                    <div id="fileList" class="row"></div>
                                </div>
                            </div>
                        </div>

                        <div id="uploadForm" style="display: none;" class="mt-4">
                            <form id="chunkedUploadForm">
                                <div class="row">
                                    <div class="col-md-6">
                                        <div class="mb-3">
                                            <label for="chunkedProjectName" class="form-label">Nom du projet</label>
                                            <input type="text" class="form-control" id="chunkedProjectName">
                                        </div>
                                    </div>
                                    <div class="col-md-6">
                                        <div class="mb-3">
                                            <label for="chunkedExpiresAt" class="form-label">Date d'expiration</label>
                                            <input type="datetime-local" class="form-control" id="chunkedExpiresAt">
                                        </div>
                                    </div>
                                </div>
                                <div class="mb-3">
                                    <label for="chunkedDescription" class="form-label">Description</label>
                                    <textarea class="form-control" id="chunkedDescription" rows="3"></textarea>
                                </div>
                                <div class="mb-3">
                                    <label for="chunkedRecipients" class="form-label">Destinataires (emails séparés par des virgules)</label>
                                    <input type="text" class="form-control" id="chunkedRecipients" 
                                           placeholder="exemple@domain.com, autre@domain.com">
                                </div>
                                <div class="d-flex gap-2">
                                    <button type="button" class="btn btn-primary" id="startChunkedUpload">
                                        <i class="bi bi-upload"></i> Démarrer l'upload
                                    </button>
                                    <button type="button" class="btn btn-secondary" id="cancelChunkedUpload">
                                        <i class="bi bi-x"></i> Annuler
                                    </button>
                                </div>
                            </form>
                        </div>

                        <div id="uploadProgress" style="display: none;" class="mt-4">
                            <div class="card">
                                <div class="card-header">
                                    <h6><i class="bi bi-upload"></i> Upload en cours</h6>
                                </div>
                                <div class="card-body">
                                    <div class="progress mb-3">
                                        <div class="progress-bar" role="progressbar" style="width: 0%"></div>
                                    </div>
                                    <div class="d-flex justify-content-between">
                                        <span id="progressText">0%</span>
                                        <span id="speedText">-</span>
                                    </div>
                                    <div class="mt-2">
                                        <small class="text-muted" id="fileInfo"></small>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div class="col-md-4">
        <!-- Upload Guidelines -->
        <div class="card mb-4">
            <div class="card-header">
                <h6><i class="bi bi-info-circle"></i> Conseils d'upload</h6>
            </div>
            <div class="card-body">
                <ul class="list-unstyled">
                    <li class="mb-2">
                        <i class="bi bi-check-circle text-success"></i>
                        <strong>Fichiers supportés:</strong> PDF, Office, images, vidéos, archives
                    </li>
                    <li class="mb-2">
                        <i class="bi bi-check-circle text-success"></i>
                        <strong>Taille maximale:</strong> 10GB par fichier
                    </li>
                    <li class="mb-2">
                        <i class="bi bi-check-circle text-success"></i>
                        <strong>Upload par chunks:</strong> Recommandé pour fichiers > 100MB
                    </li>
                    <li class="mb-2">
                        <i class="bi bi-shield-check text-info"></i>
                        <strong>Sécurité:</strong> Scan antivirus automatique
                    </li>
                    <li class="mb-2">
                        <i class="bi bi-clock text-warning"></i>
                        <strong>Expiration:</strong> Définissez une date d'expiration
                    </li>
                </ul>
            </div>
        </div>

        <!-- Current Quota -->
        <div class="card">
            <div class="card-header">
                <h6><i class="bi bi-hdd"></i> Votre quota</h6>
            </div>
            <div class="card-body">
                {% if user.quotaTotalBytes %}
                    <div class="progress quota-bar mb-2">
                        <div class="progress-bar {{ user.getQuotaUsagePercentage() > 90 ? 'bg-danger' : (user.getQuotaUsagePercentage() > 75 ? 'bg-warning' : 'bg-success') }}" 
                             role="progressbar" 
                             style="width: {{ user.getQuotaUsagePercentage() }}%">
                        </div>
                    </div>
                    <div class="d-flex justify-content-between">
                        <small>{{ (user.quotaUsedBytes / (1024*1024*1024))|number_format(2) }} GB</small>
                        <small>{{ (user.quotaTotalBytes / (1024*1024*1024))|number_format(2) }} GB</small>
                    </div>
                    <small class="text-muted">Utilisé: {{ user.getQuotaUsagePercentage()|number_format(1) }}%</small>
                {% else %}
                    <div class="text-center">
                        <i class="bi bi-infinity text-success" style="font-size: 2rem;"></i>
                        <p class="text-success mt-2">Quota illimité</p>
                    </div>
                {% endif %}
            </div>
        </div>
    </div>
</div>
{% endblock %}

{% block javascripts %}
<script>
class EnhancedChunkedUploader {
    constructor() {
        this.files = [];
        this.chunkSize = {{ chunk_size }};
        this.uploadQueue = [];
        this.currentUpload = null;
        this.startTime = null;
        
        this.initializeEventListeners();
    }

    initializeEventListeners() {
        const dropzone = document.getElementById('dropzone');
        const fileInput = document.getElementById('chunkedFileInput');
        const startBtn = document.getElementById('startChunkedUpload');
        const cancelBtn = document.getElementById('cancelChunkedUpload');
        const clearBtn = document.getElementById('clearFiles');

        dropzone.addEventListener('click', () => fileInput.click());
        dropzone.addEventListener('dragover', this.handleDragOver.bind(this));
        dropzone.addEventListener('dragleave', this.handleDragLeave.bind(this));
        dropzone.addEventListener('drop', this.handleDrop.bind(this));
        
        fileInput.addEventListener('change', this.handleFileSelect.bind(this));
        startBtn.addEventListener('click', this.startUpload.bind(this));
        cancelBtn.addEventListener('click', this.cancelUpload.bind(this));
        clearBtn.addEventListener('click', this.clearFiles.bind(this));
    }

    handleDragOver(e) {
        e.preventDefault();
        e.stopPropagation();
        const dropzone = e.currentTarget;
        dropzone.classList.add('dragover');
        
        // Update file count in overlay
        const fileCount = e.dataTransfer.items ? e.dataTransfer.items.length : 0;
        document.getElementById('fileCount').textContent = fileCount;
    }

    handleDragLeave(e) {
        e.preventDefault();
        e.stopPropagation();
        if (!e.currentTarget.contains(e.relatedTarget)) {
            e.currentTarget.classList.remove('dragover');
        }
    }

    handleDrop(e) {
        e.preventDefault();
        e.stopPropagation();
        e.currentTarget.classList.remove('dragover');
        
        const files = Array.from(e.dataTransfer.files);
        this.addFiles(files);
    }

    handleFileSelect(e) {
        const files = Array.from(e.target.files);
        this.addFiles(files);
    }

    addFiles(files) {
        files.forEach(file => {
            // Check if file already exists
            const exists = this.files.some(f => f.name === file.name && f.size === file.size);
            if (!exists) {
                this.files.push({
                    file: file,
                    id: this.generateFileId(),
                    status: 'ready',
                    progress: 0,
                    chunks: Math.ceil(file.size / this.chunkSize),
                    uploadedChunks: 0
                });
            }
        });
        
        this.updateFilePreview();
        this.updateUploadForm();
    }

    generateFileId() {
        return 'file_' + Math.random().toString(36).substr(2, 9) + '_' + Date.now();
    }

    getFileIconClass(filename) {
        const ext = filename.split('.').pop().toLowerCase();
        if (['pdf'].includes(ext)) return 'pdf';
        if (['doc', 'docx', 'xls', 'xlsx', 'ppt', 'pptx'].includes(ext)) return 'doc';
        if (['jpg', 'jpeg', 'png', 'gif', 'bmp', 'svg', 'webp'].includes(ext)) return 'image';
        if (['mp4', 'avi', 'mov', 'wmv', 'flv', 'webm'].includes(ext)) return 'video';
        if (['zip', 'rar', '7z', 'tar', 'gz'].includes(ext)) return 'archive';
        return 'default';
    }

    getFileIcon(filename) {
        const ext = filename.split('.').pop().toLowerCase();
        if (['pdf'].includes(ext)) return 'bi-file-earmark-pdf';
        if (['doc', 'docx'].includes(ext)) return 'bi-file-earmark-word';
        if (['xls', 'xlsx'].includes(ext)) return 'bi-file-earmark-excel';
        if (['ppt', 'pptx'].includes(ext)) return 'bi-file-earmark-ppt';
        if (['jpg', 'jpeg', 'png', 'gif', 'bmp', 'svg', 'webp'].includes(ext)) return 'bi-file-earmark-image';
        if (['mp4', 'avi', 'mov', 'wmv', 'flv', 'webm'].includes(ext)) return 'bi-file-earmark-play';
        if (['zip', 'rar', '7z', 'tar', 'gz'].includes(ext)) return 'bi-file-earmark-zip';
        return 'bi-file-earmark';
    }

    updateFilePreview() {
        const preview = document.getElementById('filePreview');
        const fileList = document.getElementById('fileList');
        
        if (this.files.length === 0) {
            preview.style.display = 'none';
            return;
        }
        
        preview.style.display = 'block';
        fileList.innerHTML = '';
        
        this.files.forEach((fileData, index) => {
            const file = fileData.file;
            const card = document.createElement('div');
            card.className = 'col-md-6 col-lg-4 mb-3';
            card.innerHTML = `
                <div class="file-preview-card">
                    <button type="button" class="file-remove-btn" onclick="uploader.removeFile(${index})">
                        <i class="bi bi-x"></i>
                    </button>
                    <div class="d-flex align-items-center">
                        <div class="file-type-icon ${this.getFileIconClass(file.name)}">
                            <i class="${this.getFileIcon(file.name)}"></i>
                        </div>
                        <div class="flex-grow-1">
                            <h6 class="mb-1 text-truncate" title="${file.name}">${file.name}</h6>
                            <small class="text-muted">${this.formatFileSize(file.size)}</small>
                            <div class="mt-1">
                                <span class="badge bg-secondary">${fileData.chunks} chunks</span>
                            </div>
                        </div>
                    </div>
                </div>
            `;
            fileList.appendChild(card);
        });
    }

    removeFile(index) {
        this.files.splice(index, 1);
        this.updateFilePreview();
        this.updateUploadForm();
    }

    clearFiles() {
        this.files = [];
        this.updateFilePreview();
        this.updateUploadForm();
        document.getElementById('chunkedFileInput').value = '';
    }

    updateUploadForm() {
        const uploadForm = document.getElementById('uploadForm');
        if (this.files.length > 0) {
            uploadForm.style.display = 'block';
        } else {
            uploadForm.style.display = 'none';
        }
    }

    async startUpload() {
        if (this.files.length === 0) return;

        const metadata = {
            description: document.getElementById('chunkedDescription').value,
            project_name: document.getElementById('chunkedProjectName').value,
            expires_at: document.getElementById('chunkedExpiresAt').value,
            recipients: document.getElementById('chunkedRecipients').value.split(',').map(r => r.trim()).filter(r => r)
        };

        this.startTime = Date.now();
        
        // Show progress
        document.getElementById('uploadForm').style.display = 'none';
        document.getElementById('uploadProgress').style.display = 'block';
        
        try {
            // Upload files sequentially
            for (let i = 0; i < this.files.length; i++) {
                const fileData = this.files[i];
                fileData.status = 'uploading';
                this.currentUpload = fileData;
                
                await this.uploadFile(fileData, metadata);
                
                fileData.status = 'completed';
                fileData.progress = 100;
            }
            
            alert('Tous les fichiers ont été uploadés avec succès!');
            window.location.href = '/dashboard';
            
        } catch (error) {
            alert('Erreur: ' + error.message);
            this.reset();
        }
    }

    async uploadFile(fileData, metadata) {
        const file = fileData.file;
        
        try {
            // Start upload for this file
            const response = await fetch('/api/upload/start', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    filename: file.name,
                    size: file.size,
                    ...metadata
                })
            });

            const result = await response.json();
            if (!result.success) {
                throw new Error(result.error || 'Failed to start upload');
            }

            fileData.fileId = result.file_id;
            
            // Upload chunks
            await this.uploadChunks(fileData);
            
            // Complete upload
            await this.completeFile(fileData);
            
        } catch (error) {
            fileData.status = 'error';
            throw error;
        }
    }

    async uploadChunks(fileData) {
        const file = fileData.file;
        const totalChunks = Math.ceil(file.size / this.chunkSize);
        
        for (let i = 0; i < totalChunks; i++) {
            const start = i * this.chunkSize;
            const end = Math.min(start + this.chunkSize, file.size);
            const chunk = file.slice(start, end);
            
            const formData = new FormData();
            formData.append('file_id', fileData.fileId);
            formData.append('chunk_index', i);
            formData.append('chunk_data', chunk);

            try {
                const response = await fetch('/api/upload/chunk', {
                    method: 'POST',
                    body: formData
                });

                const result = await response.json();
                if (!result.success) {
                    throw new Error(result.error || 'Failed to upload chunk');
                }

                fileData.uploadedChunks = i + 1;
                fileData.progress = (fileData.uploadedChunks / totalChunks) * 100;
                this.updateProgress(fileData);
                
            } catch (error) {
                throw new Error('Erreur lors de l\'upload du chunk ' + (i + 1) + ': ' + error.message);
            }
        }
    }

    async completeFile(fileData) {
        try {
            // Calculate checksum (SHA-256 hex)
            const checksum = await this.calculateFileHash(fileData.file);
            
            const response = await fetch('/api/upload/complete', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    file_id: fileData.fileId,
                    checksum: checksum
                })
            });

            const result = await response.json();
            if (!result.success) {
                throw new Error(result.error || 'Failed to complete upload');
            }

            return result;
            
        } catch (error) {
            throw new Error('Erreur lors de la finalisation: ' + error.message);
        }
    }

    async calculateFileHash(file) {
        // Simplified hash calculation - in production, use proper crypto
        const buffer = await file.arrayBuffer();
        const hashBuffer = await crypto.subtle.digest('SHA-256', buffer);
        const hashArray = Array.from(new Uint8Array(hashBuffer));
        return hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
    }

    updateProgress(fileData) {
        const overallProgress = this.files.reduce((sum, f) => sum + f.progress, 0) / this.files.length;
        
        document.querySelector('.progress-bar').style.width = overallProgress + '%';
        document.getElementById('progressText').textContent = 
            `${overallProgress.toFixed(1)}%`;
        
        if (this.startTime) {
            const elapsed = (Date.now() - this.startTime) / 1000;
            const totalUploaded = this.files.reduce((sum, f) => sum + (f.progress / 100) * f.file.size, 0);
            const speed = totalUploaded / elapsed;
            document.getElementById('speedText').textContent = this.formatFileSize(speed) + '/s';
        }
        
        // Update file info
        const currentFile = fileData.file;
        document.getElementById('fileInfo').textContent = 
            `Upload: ${currentFile.name} (${this.formatFileSize(currentFile.size)})`;
    }

    cancelUpload() {
        if (this.currentUpload && this.currentUpload.fileId) {
            fetch(`/api/upload/cancel/${this.currentUpload.fileId}`, {
                method: 'POST'
            });
        }
        this.reset();
    }

    reset() {
        this.files = [];
        this.currentUpload = null;
        
        document.getElementById('uploadForm').style.display = 'none';
        document.getElementById('uploadProgress').style.display = 'none';
        document.getElementById('filePreview').style.display = 'none';
        document.getElementById('chunkedFileInput').value = '';
        document.getElementById('chunkedUploadForm').reset();
        this.updateFilePreview();
    }

    formatFileSize(bytes) {
        if (bytes === 0) return '0 Bytes';
        const k = 1024;
        const sizes = ['Bytes', 'KB', 'MB', 'GB'];
        const i = Math.floor(Math.log(bytes) / Math.log(k));
        return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
    }
}

// Initialize enhanced uploader
const uploader = new EnhancedChunkedUploader();
</script>
{% endblock %}
